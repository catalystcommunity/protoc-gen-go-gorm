// Code generated by protoc-gen-go-gorm. DO NOT EDIT.
// source: cockroachdb/example.proto

package example

import (
	context "context"
	json "encoding/json"
	crdbgorm "github.com/cockroachdb/cockroach-go/v2/crdb/crdbgorm"
	gorm_jsonb "github.com/dariubs/gorm-jsonb"
	uuid "github.com/google/uuid"
	pq "github.com/lib/pq"
	lo "github.com/samber/lo"
	timestamppb "google.golang.org/protobuf/types/known/timestamppb"
	gorm "gorm.io/gorm"
	clause "gorm.io/gorm/clause"
	time "time"
)

type UserGormModel struct {

	// @gotags: fake:"skip"
	Id *string `gorm:"type:uuid;primaryKey;default:gen_random_uuid();;" json:"id" fake:"skip"`

	// @gotags: fake:"skip"
	CreatedAt *time.Time `gorm:"type:timestamp;" json:"createdAt" fake:"skip"`

	// @gotags: fake:"skip"
	UpdatedAt *time.Time `gorm:"type:timestamp;" json:"updatedAt" fake:"skip"`

	// @gotags: fake:"{price:0.00,1000.00}"
	ADouble float64 `json:"aDouble" fake:"{price:0.00,1000.00}"`

	// @gotags: fake:"{price:0.00,1000.00}"
	AFloat float32 `json:"aFloat" fake:"{price:0.00,1000.00}"`

	// @gotags: fake:"{int32}"
	AnInt32 int32 `json:"anInt32" fake:"{int32}"`

	// @gotags: fake:"{number:9223372036854775807}"
	AnInt64 int64 `json:"anInt64" fake:"{number:9223372036854775807}"`

	// @gotags: fake:"{bool}"
	ABool bool `json:"aBool" fake:"{bool}"`

	// @gotags: fake:"{hackerphrase}"
	AString string `json:"aString" fake:"{hackerphrase}"`

	// @gotags: fake:"skip"
	ABytes []byte `json:"aBytes" fake:"skip"`

	// @gotags: fake:"{price:0.00,1000.00}"
	Doubles pq.Float64Array `gorm:"type:float[];" json:"doubles" fake:"{price:0.00,1000.00}"`

	// @gotags: fake:"{price:0.00,1000.00}"
	Floats pq.Float32Array `gorm:"type:float[];" json:"floats" fake:"{price:0.00,1000.00}"`

	// @gotags: fake:"{int32}"
	Int32S pq.Int32Array `gorm:"type:int[];" json:"int32s" fake:"{int32}"`

	// @gotags: fake:"{number:9223372036854775807}"
	Int64S pq.Int64Array `gorm:"type:int[];" json:"int64s" fake:"{number:9223372036854775807}"`

	// @gotags: fake:"{bool}"
	Bools pq.BoolArray `gorm:"type:bool[];" json:"bools" fake:"{bool}"`

	// @gotags: fake:"{hackerphrase}"
	Strings pq.StringArray `gorm:"type:string[];" json:"strings" fake:"{hackerphrase}"`

	// @gotags: fake:"skip"
	Bytess pq.ByteaArray `gorm:"type:bytes[];" json:"bytess" fake:"skip"`

	// @gotags: fake:"skip"
	OptionalScalarField *string `json:"optionalScalarField" fake:"skip"`

	// @gotags: fake:"skip"
	AStructpb gorm_jsonb.JSONB `gorm:"type:jsonb" json:"aStructpb" fake:"skip"`

	// @gotags: fake:"skip"
	CompanyId *string `json:"companyId" fake:"skip"`

	// @gotags: fake:"skip"
	Company *CompanyGormModel `gorm:"foreignKey:CompanyId;references:Id;constraint:OnDelete:CASCADE;" json:"company" fake:"skip"`

	// @gotags: fake:"skip"
	CompanyTwoId *string `json:"companyTwoId" fake:"skip"`

	// @gotags: fake:"skip"
	CompanyTwo *CompanyGormModel `gorm:"foreignKey:CompanyTwoId;references:Id;constraint:OnDelete:CASCADE;" json:"companyTwo" fake:"skip"`

	// @gotags: fake:"skip"
	AnUnexpectedId *string `json:"anUnexpectedId" fake:"skip"`

	// @gotags: fake:"skip"
	CompanyThree *CompanyGormModel `gorm:"foreignKey:AnUnexpectedId;references:Id;constraint:OnDelete:CASCADE;" json:"companyThree" fake:"skip"`

	// @gotags: fake:"skip"
	Address *AddressGormModel `gorm:"foreignKey:UserId;references:Id;constraint:OnDelete:CASCADE;" json:"address" fake:"skip"`

	// @gotags: fake:"skip"
	Comments []*CommentGormModel `gorm:"foreignKey:UserId;references:Id;constraint:OnDelete:CASCADE;" json:"comments" fake:"skip"`

	// @gotags: fake:"skip"
	Profiles []*ProfileGormModel `gorm:"foreignKey:Id;references:Id;many2many:users_profiles;joinForeignKey:UserId;joinReferences:ProfileId;constraint:OnDelete:CASCADE;" json:"profiles" fake:"skip"`

	// @gotags: fake:"{number:1,9}"
	IntEnum int `json:"intEnum" fake:"{number:1,9}"`

	// @gotags: fake:"{number:1,9}"
	StringEnum string `json:"stringEnum" fake:"{number:1,9}"`

	// @gotags: fake:"{number:1,9}"
	IntEnumList pq.Int32Array `gorm:"type:int[];" json:"intEnumList" fake:"{number:1,9}"`

	// @gotags: fake:"{number:1,9}"
	StringEnumList pq.StringArray `gorm:"type:string[];" json:"stringEnumList" fake:"{number:1,9}"`

	// @gotags: fake:"{date:2006-01-02}"
	Date *time.Time `json:"date" fake:"{date:2006-01-02}"`

	// @gotags: fake:"{date:2006-01-02}"
	OptionalDate *time.Time `json:"optionalDate" fake:"{date:2006-01-02}"`

	// @gotags: fake:"skip"
	SomeTimestamp *time.Time `gorm:"type:timestamp;" json:"someTimestamp" fake:"skip"`
}

func (m *UserGormModel) TableName() string {
	return "users"
}

func (m *UserGormModel) ToProto() (theProto *User, err error) {
	if m == nil {
		return
	}
	theProto = &User{}

	theProto.Id = m.Id

	if m.CreatedAt != nil {
		theProto.CreatedAt = m.CreatedAt.Format(time.RFC3339Nano)
	}

	if m.UpdatedAt != nil {
		theProto.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}

	theProto.ADouble = m.ADouble

	theProto.AFloat = m.AFloat

	theProto.AnInt32 = m.AnInt32

	theProto.AnInt64 = m.AnInt64

	theProto.ABool = m.ABool

	theProto.AString = m.AString

	theProto.ABytes = m.ABytes

	theProto.Doubles = m.Doubles

	theProto.Floats = m.Floats

	theProto.Int32S = m.Int32S

	theProto.Int64S = m.Int64S

	theProto.Bools = m.Bools

	theProto.Strings = m.Strings

	theProto.Bytess = m.Bytess

	theProto.OptionalScalarField = m.OptionalScalarField

	if m.AStructpb != nil {
		var jsonBytes []byte
		if jsonBytes, err = json.Marshal(m.AStructpb); err != nil {
			return
		}
		if err = json.Unmarshal(jsonBytes, &theProto.AStructpb); err != nil {
			return
		}
	}

	theProto.CompanyId = m.CompanyId

	if theProto.Company, err = m.Company.ToProto(); err != nil {
		return
	}

	theProto.CompanyTwoId = m.CompanyTwoId

	if theProto.CompanyTwo, err = m.CompanyTwo.ToProto(); err != nil {
		return
	}

	theProto.AnUnexpectedId = m.AnUnexpectedId

	if theProto.CompanyThree, err = m.CompanyThree.ToProto(); err != nil {
		return
	}

	if theProto.Address, err = m.Address.ToProto(); err != nil {
		return
	}

	if len(m.Comments) > 0 {
		theProto.Comments = []*Comment{}
		for _, item := range m.Comments {
			var CommentsProto *Comment
			if CommentsProto, err = item.ToProto(); err != nil {
				return
			} else {
				theProto.Comments = append(theProto.Comments, CommentsProto)
			}
		}
	}

	if len(m.Profiles) > 0 {
		theProto.Profiles = []*Profile{}
		for _, item := range m.Profiles {
			var ProfilesProto *Profile
			if ProfilesProto, err = item.ToProto(); err != nil {
				return
			} else {
				theProto.Profiles = append(theProto.Profiles, ProfilesProto)
			}
		}
	}

	theProto.IntEnum = EnumOne(m.IntEnum)

	theProto.StringEnum = EnumOne(EnumOne_value[m.StringEnum])

	if len(m.IntEnumList) > 0 {
		theProto.IntEnumList = []EnumOne{}
		for _, val := range m.IntEnumList {
			theProto.IntEnumList = append(theProto.IntEnumList, EnumOne(val))
		}
	}

	if len(m.StringEnumList) > 0 {
		theProto.StringEnumList = []EnumOne{}
		for _, val := range m.StringEnumList {
			theProto.StringEnumList = append(theProto.StringEnumList, EnumOne(EnumOne_value[val]))
		}
	}

	if m.Date != nil {
		theProto.Date = m.Date.UTC().Format("2006-01-02")
	}

	if m.OptionalDate != nil {
		theProto.OptionalDate = lo.ToPtr(m.OptionalDate.UTC().Format("2006-01-02"))
	}

	if m.SomeTimestamp != nil {
		theProto.SomeTimestamp = timestamppb.New(*m.SomeTimestamp)
	}

	return
}

func (p *User) GetProtoId() *string {
	return p.Id
}

func (p *User) SetProtoId(id string) {
	p.Id = lo.ToPtr(id)
}

func (p *User) ToModel() (theModel *UserGormModel, err error) {
	if p == nil {
		return
	}
	theModel = &UserGormModel{}

	theModel.Id = p.Id

	if p.CreatedAt != "" {
		var timestamp time.Time
		if timestamp, err = time.Parse(time.RFC3339Nano, p.CreatedAt); err != nil {
			return
		}
		theModel.CreatedAt = &timestamp
	}

	if p.UpdatedAt != nil {
		theModel.UpdatedAt = lo.ToPtr(p.UpdatedAt.AsTime())
	}

	theModel.ADouble = p.ADouble

	theModel.AFloat = p.AFloat

	theModel.AnInt32 = p.AnInt32

	theModel.AnInt64 = p.AnInt64

	theModel.ABool = p.ABool

	theModel.AString = p.AString

	theModel.ABytes = p.ABytes

	theModel.Doubles = p.Doubles

	theModel.Floats = p.Floats

	theModel.Int32S = p.Int32S

	theModel.Int64S = p.Int64S

	theModel.Bools = p.Bools

	theModel.Strings = p.Strings

	theModel.Bytess = p.Bytess

	theModel.OptionalScalarField = p.OptionalScalarField

	if p.AStructpb != nil {
		var jsonBytes []byte
		if jsonBytes, err = json.Marshal(p.AStructpb); err != nil {
			return
		}
		if err = json.Unmarshal(jsonBytes, &theModel.AStructpb); err != nil {
			return
		}
	}

	theModel.CompanyId = p.CompanyId

	if theModel.Company, err = p.Company.ToModel(); err != nil {
		return
	}

	// if the object is present, the object's id overrides the existing id field value
	if p.Company != nil {
		theModel.CompanyId = p.Company.Id
	}

	theModel.CompanyTwoId = p.CompanyTwoId

	if theModel.CompanyTwo, err = p.CompanyTwo.ToModel(); err != nil {
		return
	}

	// if the object is present, the object's id overrides the existing id field value
	if p.CompanyTwo != nil {
		theModel.CompanyTwoId = p.CompanyTwo.Id
	}

	theModel.AnUnexpectedId = p.AnUnexpectedId

	if theModel.CompanyThree, err = p.CompanyThree.ToModel(); err != nil {
		return
	}

	// if the object is present, the object's id overrides the existing id field value
	if p.CompanyThree != nil {
		theModel.AnUnexpectedId = p.CompanyThree.Id
	}

	if theModel.Address, err = p.Address.ToModel(); err != nil {
		return
	}

	if len(p.Comments) > 0 {
		theModel.Comments = []*CommentGormModel{}
		for _, item := range p.Comments {
			var CommentsModel *CommentGormModel
			if CommentsModel, err = item.ToModel(); err != nil {
				return
			} else {
				theModel.Comments = append(theModel.Comments, CommentsModel)
			}
		}
	}

	if len(p.Profiles) > 0 {
		theModel.Profiles = []*ProfileGormModel{}
		for _, item := range p.Profiles {
			var ProfilesModel *ProfileGormModel
			if ProfilesModel, err = item.ToModel(); err != nil {
				return
			} else {
				theModel.Profiles = append(theModel.Profiles, ProfilesModel)
			}
		}
	}

	theModel.IntEnum = int(p.IntEnum)

	theModel.StringEnum = p.StringEnum.String()

	if len(p.IntEnumList) > 0 {
		theModel.IntEnumList = pq.Int32Array{}
		for _, val := range p.IntEnumList {
			theModel.IntEnumList = append(theModel.IntEnumList, int32(val))
		}
	}

	if len(p.StringEnumList) > 0 {
		theModel.StringEnumList = pq.StringArray{}
		for _, val := range p.StringEnumList {
			theModel.StringEnumList = append(theModel.StringEnumList, val.String())
		}
	}

	if p.Date != "" {
		var date time.Time
		if date, err = time.Parse("2006-01-02", p.Date); err != nil {
			return
		}
		dateUTC := date.UTC()
		theModel.Date = &dateUTC
	}

	if p.OptionalDate != nil {
		var date time.Time
		if date, err = time.Parse("2006-01-02", *p.OptionalDate); err != nil {
			return
		}
		dateUTC := date.UTC()
		theModel.OptionalDate = &dateUTC
	}

	if p.SomeTimestamp != nil {
		theModel.SomeTimestamp = lo.ToPtr(p.SomeTimestamp.AsTime())
	}

	return
}

type CompanyGormModel struct {

	// @gotags: fake:"skip"
	Id *string `gorm:"type:uuid;primaryKey;default:gen_random_uuid();;" json:"id" fake:"skip"`

	// @gotags: fake:"skip"
	CreatedAt *time.Time `gorm:"type:timestamp;" json:"createdAt" fake:"skip"`

	// @gotags: fake:"skip"
	UpdatedAt *time.Time `gorm:"type:timestamp;" json:"updatedAt" fake:"skip"`

	// @gotags: fake:"{name}"
	Name string `json:"name" fake:"{name}"`
}

func (m *CompanyGormModel) TableName() string {
	return "companies"
}

func (m *CompanyGormModel) ToProto() (theProto *Company, err error) {
	if m == nil {
		return
	}
	theProto = &Company{}

	theProto.Id = m.Id

	if m.CreatedAt != nil {
		theProto.CreatedAt = timestamppb.New(*m.CreatedAt)
	}

	if m.UpdatedAt != nil {
		theProto.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}

	theProto.Name = m.Name

	return
}

func (p *Company) GetProtoId() *string {
	return p.Id
}

func (p *Company) SetProtoId(id string) {
	p.Id = lo.ToPtr(id)
}

func (p *Company) ToModel() (theModel *CompanyGormModel, err error) {
	if p == nil {
		return
	}
	theModel = &CompanyGormModel{}

	theModel.Id = p.Id

	if p.CreatedAt != nil {
		theModel.CreatedAt = lo.ToPtr(p.CreatedAt.AsTime())
	}

	if p.UpdatedAt != nil {
		theModel.UpdatedAt = lo.ToPtr(p.UpdatedAt.AsTime())
	}

	theModel.Name = p.Name

	return
}

type AddressGormModel struct {

	// @gotags: fake:"skip"
	Id *string `gorm:"type:uuid;primaryKey;default:gen_random_uuid();;" json:"id" fake:"skip"`

	// @gotags: fake:"skip"
	CreatedAt *time.Time `gorm:"type:timestamp;" json:"createdAt" fake:"skip"`

	// @gotags: fake:"skip"
	UpdatedAt *time.Time `gorm:"type:timestamp;" json:"updatedAt" fake:"skip"`

	// @gotags: fake:"{name}"
	Name string `json:"name" fake:"{name}"`

	// @gotags: fake:"skip"
	UserId *string `json:"userId" fake:"skip"`

	// @gotags: fake:"skip"
	User *UserGormModel `gorm:"foreignKey:UserId;references:Id;constraint:OnDelete:CASCADE;" json:"user" fake:"skip"`

	// @gotags: fake:"skip"
	CompanyBlob gorm_jsonb.JSONB `gorm:"type:jsonb" json:"companyBlob" fake:"skip"`
}

func (m *AddressGormModel) TableName() string {
	return "addresses"
}

func (m *AddressGormModel) ToProto() (theProto *Address, err error) {
	if m == nil {
		return
	}
	theProto = &Address{}

	theProto.Id = m.Id

	if m.CreatedAt != nil {
		theProto.CreatedAt = timestamppb.New(*m.CreatedAt)
	}

	if m.UpdatedAt != nil {
		theProto.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}

	theProto.Name = m.Name

	theProto.UserId = m.UserId

	if theProto.User, err = m.User.ToProto(); err != nil {
		return
	}

	if m.CompanyBlob != nil {
		var jsonBytes []byte
		if jsonBytes, err = json.Marshal(m.CompanyBlob); err != nil {
			return
		}
		if err = json.Unmarshal(jsonBytes, &theProto.CompanyBlob); err != nil {
			return
		}
	}

	return
}

func (p *Address) GetProtoId() *string {
	return p.Id
}

func (p *Address) SetProtoId(id string) {
	p.Id = lo.ToPtr(id)
}

func (p *Address) ToModel() (theModel *AddressGormModel, err error) {
	if p == nil {
		return
	}
	theModel = &AddressGormModel{}

	theModel.Id = p.Id

	if p.CreatedAt != nil {
		theModel.CreatedAt = lo.ToPtr(p.CreatedAt.AsTime())
	}

	if p.UpdatedAt != nil {
		theModel.UpdatedAt = lo.ToPtr(p.UpdatedAt.AsTime())
	}

	theModel.Name = p.Name

	theModel.UserId = p.UserId

	if theModel.User, err = p.User.ToModel(); err != nil {
		return
	}

	// if the object is present, the object's id overrides the existing id field value
	if p.User != nil {
		theModel.UserId = p.User.Id
	}

	if p.CompanyBlob != nil {
		var jsonBytes []byte
		if jsonBytes, err = json.Marshal(p.CompanyBlob); err != nil {
			return
		}
		if err = json.Unmarshal(jsonBytes, &theModel.CompanyBlob); err != nil {
			return
		}
	}

	return
}

type CommentGormModel struct {

	// @gotags: fake:"skip"
	Id *string `gorm:"type:uuid;primaryKey;default:gen_random_uuid();;" json:"id" fake:"skip"`

	// @gotags: fake:"skip"
	CreatedAt *time.Time `gorm:"type:timestamp;" json:"createdAt" fake:"skip"`

	// @gotags: fake:"skip"
	UpdatedAt *time.Time `gorm:"type:timestamp;" json:"updatedAt" fake:"skip"`

	// @gotags: fake:"{name}"
	Name string `json:"name" fake:"{name}"`

	// @gotags: fake:"skip"
	UserId *string `json:"userId" fake:"skip"`

	// @gotags: fake:"skip"
	User *UserGormModel `gorm:"foreignKey:UserId;references:Id;constraint:OnDelete:CASCADE;" json:"user" fake:"skip"`
}

func (m *CommentGormModel) TableName() string {
	return "comments"
}

func (m *CommentGormModel) ToProto() (theProto *Comment, err error) {
	if m == nil {
		return
	}
	theProto = &Comment{}

	theProto.Id = m.Id

	if m.CreatedAt != nil {
		theProto.CreatedAt = timestamppb.New(*m.CreatedAt)
	}

	if m.UpdatedAt != nil {
		theProto.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}

	theProto.Name = m.Name

	theProto.UserId = m.UserId

	if theProto.User, err = m.User.ToProto(); err != nil {
		return
	}

	return
}

func (p *Comment) GetProtoId() *string {
	return p.Id
}

func (p *Comment) SetProtoId(id string) {
	p.Id = lo.ToPtr(id)
}

func (p *Comment) ToModel() (theModel *CommentGormModel, err error) {
	if p == nil {
		return
	}
	theModel = &CommentGormModel{}

	theModel.Id = p.Id

	if p.CreatedAt != nil {
		theModel.CreatedAt = lo.ToPtr(p.CreatedAt.AsTime())
	}

	if p.UpdatedAt != nil {
		theModel.UpdatedAt = lo.ToPtr(p.UpdatedAt.AsTime())
	}

	theModel.Name = p.Name

	theModel.UserId = p.UserId

	if theModel.User, err = p.User.ToModel(); err != nil {
		return
	}

	// if the object is present, the object's id overrides the existing id field value
	if p.User != nil {
		theModel.UserId = p.User.Id
	}

	return
}

type ProfileGormModel struct {

	// @gotags: fake:"skip"
	Id *string `gorm:"type:uuid;primaryKey;default:gen_random_uuid();;" json:"id" fake:"skip"`

	// @gotags: fake:"skip"
	CreatedAt *time.Time `gorm:"type:timestamp;" json:"createdAt" fake:"skip"`

	// @gotags: fake:"skip"
	UpdatedAt *time.Time `gorm:"type:timestamp;" json:"updatedAt" fake:"skip"`

	// @gotags: fake:"{name}"
	Name string `json:"name" fake:"{name}"`
}

func (m *ProfileGormModel) TableName() string {
	return "profiles"
}

func (m *ProfileGormModel) ToProto() (theProto *Profile, err error) {
	if m == nil {
		return
	}
	theProto = &Profile{}

	theProto.Id = m.Id

	if m.CreatedAt != nil {
		theProto.CreatedAt = timestamppb.New(*m.CreatedAt)
	}

	if m.UpdatedAt != nil {
		theProto.UpdatedAt = timestamppb.New(*m.UpdatedAt)
	}

	theProto.Name = m.Name

	return
}

func (p *Profile) GetProtoId() *string {
	return p.Id
}

func (p *Profile) SetProtoId(id string) {
	p.Id = lo.ToPtr(id)
}

func (p *Profile) ToModel() (theModel *ProfileGormModel, err error) {
	if p == nil {
		return
	}
	theModel = &ProfileGormModel{}

	theModel.Id = p.Id

	if p.CreatedAt != nil {
		theModel.CreatedAt = lo.ToPtr(p.CreatedAt.AsTime())
	}

	if p.UpdatedAt != nil {
		theModel.UpdatedAt = lo.ToPtr(p.UpdatedAt.AsTime())
	}

	theModel.Name = p.Name

	return
}

// Protos is a union of other types that defines which types may be used in generic functions
type Protos interface {
	*User | *Company | *Address | *Comment | *Profile
}

// Models is a union of other types that defines which types may be used in generic functions
type Models interface {
	*UserGormModel | *CompanyGormModel | *AddressGormModel | *CommentGormModel | *ProfileGormModel
}

// Proto[M Models] is an interface type that defines behavior for the implementer of a given Models type
type Proto[M Models] interface {
	GetProtoId() *string
	SetProtoId(string)
	ToModel() (M, error)
}

// Model[P Protos] is an interface type that defines behavior for the implementer of a given Protos type
type Model[P Protos] interface {
	ToProto() (P, error)
}

// ToModels converts an array of protos to an array of gorm db models by calling the proto's ToModel method
func ToModels[P Protos, M Models](protos interface{}) ([]M, error) {
	converted := ConvertProtosToProtosM[P, M](protos)
	models := []M{}
	for _, proto := range converted {
		model, err := proto.ToModel()
		if err != nil {
			return nil, err
		}
		models = append(models, model)
	}
	return models, nil
}

// ConvertProtosToProtosM converts a given slice of protos into an array of the Proto interface type, which can then
// leverage the interface methods
func ConvertProtosToProtosM[P Protos, M Models](protos interface{}) []Proto[M] {
	assertedProtos := protos.([]P)
	things := make([]Proto[M], len(assertedProtos))
	for i, v := range assertedProtos {
		things[i] = ConvertProtoToProtosM[P, M](v)
	}
	return things
}

// ConvertProtoToProtosM converts a single proto to a Proto[M]
func ConvertProtoToProtosM[P Protos, M Models](proto interface{}) Proto[M] {
	return any(proto).(Proto[M])
}

// ConvertProtosToProtosM converts a given slice of protos into an array of the Proto interface type, which can then
// leverage the interface methods
func ConvertModelsToModelsP[P Protos, M Models](models interface{}) []Model[P] {
	assertedModels := models.([]M)
	things := make([]Model[P], len(assertedModels))
	for i, v := range assertedModels {
		things[i] = ConvertModelToModelP[P, M](v)
	}
	return things
}

// ConvertProtoToProtosM converts a single proto to a Proto[M]
func ConvertModelToModelP[P Protos, M Models](model interface{}) Model[P] {
	return any(model).(Model[P])
}

// ToProtos converts an array of models into an array of protos by calling the model's ToProto method
func ToProtos[P Protos, M Models](models interface{}) ([]P, error) {
	converted := ConvertModelsToModelsP[P, M](models)
	protos := []P{}
	for _, model := range converted {
		proto, err := model.ToProto()
		if err != nil {
			return nil, err
		}
		protos = append(protos, proto)
	}
	return protos, nil
}

// Upsert is a generic function that will upsert any of the generated protos, returning the upserted models. Upsert
// excludes all associations, and uses an on conflict clause to handle upsert. A function may be provided to be executed
// during the transaction. The function is executed after the upsert. If the function returns an error, the transaction
// will be rolled back.
func Upsert[P Protos, M Models](ctx context.Context, db *gorm.DB, protos interface{}, txFunc func(ctx context.Context, tx *gorm.DB, protos []Proto[M], models []M) error) ([]M, error) {
	converted := ConvertProtosToProtosM[P, M](protos)
	if len(converted) > 0 {
		models := []M{}
		for _, proto := range converted {
			if proto.GetProtoId() == nil {
				proto.SetProtoId(uuid.New().String())
			}
			model, err := proto.ToModel()
			if err != nil {
				return nil, err
			}
			models = append(models, model)
		}
		err := crdbgorm.ExecuteTx(ctx, db, nil, func(tx *gorm.DB) error {
			txErr := tx.
				// on conflict, update all fields
				Clauses(clause.OnConflict{
					UpdateAll: true,
				}).
				// exclude associations from upsert
				Omit(clause.Associations).
				Create(&models).Error
			if txErr != nil {
				return txErr
			}
			// if a txFunc is specified, execute it
			if txFunc != nil {
				txErr = txFunc(ctx, tx, converted, models)
				if txErr != nil {
					return txErr
				}
			}
			return nil
		})

		return models, err
	}
	return nil, nil
}

// Delete is a generic function that will delete any of the generated protos. A function may be provided to be executed
// during the transaction. The function is executed after the delete. If the function returns an error, the transaction
// will be rolled back.
func Delete[M Models](ctx context.Context, db *gorm.DB, ids []string, txFunc func(ctx context.Context, tx *gorm.DB, ids []string) error) error {
	if len(ids) > 0 {
		return crdbgorm.ExecuteTx(ctx, db, nil, func(tx *gorm.DB) error {
			models := []M{}
			txErr := tx.Where("id in ?", ids).Delete(&models).Error
			if txErr != nil {
				return txErr
			}
			// if a txFunc is specified, execute it
			if txFunc != nil {
				txErr = txFunc(ctx, tx, ids)
				if txErr != nil {
					return txErr
				}
			}
			return nil
		})
	}
	return nil
}

// List lists the given model type
func List[M Models](ctx context.Context, db *gorm.DB, limit, offset int, orderBy string, preloads []string) ([]M, error) {
	session := db.Session(&gorm.Session{}).WithContext(ctx)
	// set limit
	if limit > 0 {
		session = session.Limit(limit)
	}
	// set offset
	if offset > 0 {
		session = session.Offset(offset)
	}
	// set preloads
	for _, preload := range preloads {
		session = session.Preload(preload)
	}
	// set order by
	if orderBy != "" {
		session = session.Order(orderBy)
	}
	// execute
	var models []M
	err := session.Find(&models).Error
	return models, err
}

// GetByIds gets the given model type by id
func GetByIds[M Models](ctx context.Context, db *gorm.DB, ids []string, preloads []string) ([]M, error) {
	session := db.Session(&gorm.Session{}).WithContext(ctx)
	// set preloads
	for _, preload := range preloads {
		session = session.Preload(preload)
	}
	models := []M{}
	err := session.Where("id in ?", ids).Find(&models).Error
	return models, err
}

func AssociateManyToMany[L Models, R Models](ctx context.Context, db *gorm.DB, associations map[L][]R, associationName string, txFunc func(ctx context.Context, tx *gorm.DB) error) error {
	return crdbgorm.ExecuteTx(ctx, db, nil, func(tx *gorm.DB) error {
		for model, newAssociations := range associations {
			txErr := tx.Model(&model).Association(associationName).Append(&newAssociations)
			if txErr != nil {
				return txErr
			}
		}
		// if a txFunc is specified, execute it
		if txFunc != nil {
			txErr := txFunc(ctx, tx)
			if txErr != nil {
				return txErr
			}
		}
		return nil
	})
}

func DissociateManyToMany[L Models, R Models](ctx context.Context, db *gorm.DB, associations map[L][]R, associationName string, txFunc func(ctx context.Context, tx *gorm.DB) error) error {
	return crdbgorm.ExecuteTx(ctx, db, nil, func(tx *gorm.DB) error {
		for model, newAssociations := range associations {
			txErr := tx.Model(&model).Association(associationName).Delete(&newAssociations)
			if txErr != nil {
				return txErr
			}
		}
		// if a txFunc is specified, execute it
		if txFunc != nil {
			txErr := txFunc(ctx, tx)
			if txErr != nil {
				return txErr
			}
		}
		return nil
	})
}
